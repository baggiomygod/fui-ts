# interview
## 1.页面布局
  ### 1.1 float布局（圣杯布局、双飞翼布局）
    优点：兼容性好
    缺点：float脱离文档流，需要清除浮动。否则会有问题
  ### 1.2 position 绝对定位布局
    优点：易于实现
    缺点：由于本身脱离文档流，影响到其他元素。实用性差
  ### 1.3 table布局（table, table-cell）
    优点：兼容性较好、简单开发熟读快、内容自适应、易于SEO
    缺点：性能较差（）
  ### 1.4 flex-box布局
    优点：较完善
    缺点：兼容性不是非常好（ie8不支持）
  ### 1.5 grid布局
    优点：标准话栅格系统。代码量少
    缺点：新技术，兼容性较差
## 2. HTTP
### 2.1 特点
- 简单快速
- 灵活
- 无连接：连接一次就断掉
- 无状态：客户端第二次访问 服务端是不会识别的

### 2.2 HTTP报文
1. 请求报文
  请求行：包含：HTTP方法、页面地址、HTTP协议和版本。
  请求头：key:value形式的值，
  空行: 空行之后是请求体
  请求体:
2. 响应报文
  状态行：协议版本 状态码；HTTP/1.1 200 OK
  响应头：key:value形式的值，
  空行：空行之后是响应体
  响应体：

3. HTTP方法
- GET 获取资源
- POST 传输资源
- PUT 更新资源
- DELETE 删除资源
- HEAD 获取报文首部

### POST 和 GET的区别(http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml)
1. GET是浏览器回退无害的，POST会再次请求
2. GET请求会被浏览器主动缓存，而POST不会，除非手动设置
3. GET请求参数会被完整的保留在浏览器历史记录里，POST中的参数不会被保留
4. GET请求在URL中传送的参数长度有限制（一般2kb）,POST没有限制
    > - HTTP规范中GET,POST对参数的长度都没有限制；
    > - 以往所说的GET有长度限制，都是浏览器的原因（大都限制在2k以内,服务器最多处理64k大小的url），也就是web开发中的规定。
    > - GET和POST本质上就是TCP连接。由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中出现的不同
5. GET比POST不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
6. GET参数通过URL传递，POST放在request body中.
   > GET 参数跟在URL后，为明文。（技术上也是可以将参数放在请求体中，但不能保证被所有服务端接收）

7. **GET产生一个TCP包，POST产生2个TCP数据包**
    - 对于GET方式来说，浏览器会把HTTP Header和data一并发送出去，服务器响应200(返回数据)
    - 对于POST，浏览器先发送header,服务端响应100 continue,浏览器再发送data,服务端响应200 ok(返回数据)。（并不是所有浏览器POST都发2次包，火狐就只发一次）
8. 语义上：GET多用于从服务器获取数据;语义上：POST用于向服务器提交数据
other:
1. GET产生的URL地址可以被收藏，POST不可以
2. GET请求只能进行url编码，POST支持多种编码方式
3. 对参数的数据类型，GET只接受ASCII字符，POST没有限制

### HTTP状态码
- 1xx 知识信息：表示请求已经接收，继续处理
- 2xx 成功： 表示请求已被成功接收
  1. 200 ok:客户端请求成功
  2. 206 Partial Content: 客户发送了一个带有range头的GET请求， 服务器完成了它
- 3xx 重定向：要完成请求必须进行更进一步的操作
  1. 301：所有请求的页面已经转移到新的url
  2. 302: 所请求的页面已临时转移到新url
  3. 304: 客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户端：原来缓存中的文档还可以继续使用。
- 4xx 客户端错误：请求有语法错误或请求无法实现
  1. 400 bad Request 客户端请求有预发错误，不能被服务器所理解
  2. 401 Unauthorized 请求未经授权，这个状态码必须和WWW-Autherticate报头域一起使用
  3. 403 Forbidden 对被请丢的页面的访问被禁止
  4. 404 请求的资源不存在
- 5xx 服务器错误：服务器未能实现合法的请求
  1. 500 服务器发生不可预期的错误,原来缓存文件可以继续使用
  2. 503 请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常

### HTTP协议类--持久连接Keep-Alive
HTTP1.1版本支持持久连接
1. 非持久连接
Http协议采用“请求--应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）

2. 持久连接
当使用Keep-Alive模式(持久连接、连接重用)时，keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求是，keep-alive功能避免了建立或者重新建立连接。

### HTTP协议---管线化（重点：1.基于持久了解；2.GET,HEAD支持，POST有所限制；3.HTTP1.1支持；4.原理：多个请求打包，响应也多个打包一起返回）
在使用持久连接的情况下，某个连接上消息的传递类似于：
请求1-->响应1-->请求2-->响应2-->请求3-->响应3

管线化：在持久连接的情况下完成
多个请求打包发送，多个响应也一起返回
请求1-->请求2-->请求3-->响应1-->响应2-->响应3

1. 管线化机制通过持久连接完成，仅HTTP/1.1支持技术
2. 只有GET和HEAD请求可以进行管线化，而POST则有所限制
3. 初次创建连接时不应启动管线化机制，因为服务器不一定支持HTTP/1.1版本的协议
4. HTTP/1.1 要求服务器支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对管线化的请求不失败即可
5. 由于上面提到的服务器问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，现代浏览器默认并未开启管线化支持。
